AWSTemplateFormatVersion: '2010-09-09'


Parameters:
  Stage:
    Type: String
    Default: dev
  RoleARN:
    Type: String
    Default: "arn:aws:iam::373971603424:role/LabRole"
  Region:
    Type: String
    Default: "us-east-1"

Resources:
  UsersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "user-table-${Stage}"
      AttributeDefinitions:
        - AttributeName: email
          AttributeType: S
      KeySchema:
        - AttributeName: email
          KeyType: HASH
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5

  ChatsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "chat-table-${Stage}"
      AttributeDefinitions:
        - AttributeName: chatId
          AttributeType: S
      KeySchema:
        - AttributeName: chatId
          KeyType: HASH
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5

  MessagesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "message-table-${Stage}"
      AttributeDefinitions:
        - AttributeName: messageId
          AttributeType: S
      KeySchema:
        - AttributeName: messageId
          KeyType: HASH
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5



# Done
  CreateUserFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, PutCommand } = require("@aws-sdk/lib-dynamodb");
          const { S3Client, PutObjectCommand } = require("@aws-sdk/client-s3");

          const ddbClient = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
          const s3Client = new S3Client({});
          const USERS_TABLE = process.env.USERS_TABLE;
          const BUCKET_NAME = process.env.BUCKET_NAME;

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,POST"
              }
            };

            try {
              const { userName, email, password, profilePicture } = JSON.parse(event.body);
              const userId = generateUUID();
              const createdAT = new Date().toISOString();
              const updatedAt = createdAT;

              const profilePictureKey = `profile-pictures/${userId}.png`;
              await s3Client.send(new PutObjectCommand({
                Bucket: BUCKET_NAME,
                Key: profilePictureKey,
                Body: Buffer.from(profilePicture, 'base64'),
                ContentEncoding: 'base64',
                ContentType: 'image/png'
              }));

              await ddbDocClient.send(new PutCommand({
                TableName: USERS_TABLE,
                Item: {
                  userId,
                  userName,
                  email,
                  password,
                  profilePicture: `https://${BUCKET_NAME}.s3.amazonaws.com/${profilePictureKey}`,
                  createdAT,
                  updatedAt
                }
              }));

              return {
                ...response,
                body: JSON.stringify({ message: 'User created successfully' })
              };
            } catch (error) {
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({ message: `Error creating user: ${error.message}` })
              };
            }
          };

          function generateUUID() {
            // Generate random numbers
            function getRandomInt(min, max) {
              return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            // Generate a UUID v4
            const randomBytes = [];
            for (let i = 0; i < 16; i++) {
              randomBytes.push(getRandomInt(0, 255));
            }

            // Set the version to 4 (UUID v4)
            randomBytes[6] = (randomBytes[6] & 0x0f) | 0x40; // version 4
            // Set the variant to 1 (RFC 4122 variant)
            randomBytes[8] = (randomBytes[8] & 0x3f) | 0x80;

            // Convert bytes to a UUID string
            const hex = randomBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');
            return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
          }


      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          USERS_TABLE: !Ref UsersTable
          BUCKET_NAME: "profile-picture-bucket-term-project"

  CreateUserHandlerLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref CreateUserFunction
      Principal: 'apigateway.amazonaws.com'

  ApiGatewayResourceCreateUser:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'create-user'

  ApiGatewayMethodCreateUser:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceCreateUser
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.header.Content-Type": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceCreateUser
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${CreateUserFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: {}

  ApiGatewayMethodOptionsCreateUser:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceCreateUser
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceCreateUser
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'POST,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"



# Done
  LoginFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, GetCommand } = require("@aws-sdk/lib-dynamodb");

          const ddbClient = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
          const USERS_TABLE = process.env.USERS_TABLE;

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,POST"
              }
            };

            try {
              const { email, password } = JSON.parse(event.body);

              const result = await ddbDocClient.send(new GetCommand({
                TableName: USERS_TABLE,
                Key: { email }
              }));

              if (!result.Item || result.Item.password !== password) {
                return {
                  ...response,
                  statusCode: 401,
                  body: JSON.stringify({ message: 'Invalid email or password' })
                };
              }

              return {
                ...response,
                body: JSON.stringify(result.Item)
              };
            } catch (error) {
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({ message: `Error logging in: ${error.message}` })
              };
            }
          };
      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          USERS_TABLE: !Ref UsersTable

  LoginHandlerLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref LoginFunction
      Principal: 'apigateway.amazonaws.com'

  ApiGatewayResourceLogin:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'login'

  ApiGatewayMethodLogin:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceLogin
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.header.Content-Type": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceLogin
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LoginFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: {}

  ApiGatewayMethodOptionsLogin:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceLogin
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceLogin
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'POST,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"




# Done
  CreateChatFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, PutCommand } = require("@aws-sdk/lib-dynamodb");

          const ddbClient = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
          const CHATS_TABLE = process.env.CHATS_TABLE;

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,POST"
              }
            };

            try {
              const { userId1, userId2, chatName } = JSON.parse(event.body);
              const chatId = generateUUID();
              const createdAt = new Date().toISOString();
              const updatedAt = createdAt;

              await ddbDocClient.send(new PutCommand({
                TableName: CHATS_TABLE,
                Item: {
                  chatId,
                  chatName,
                  users: [userId1, userId2],
                  createdAt,
                  updatedAt,
                  lastMessageSent: null
                }
              }));

              return {
                ...response,
                body: JSON.stringify({ message: 'Chat created successfully' })
              };
            } catch (error) {
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({ message: `Error creating chat: ${error.message}` })
              };
            }
          };

          function generateUUID() {
            // Generate random numbers
            function getRandomInt(min, max) {
              return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            // Generate a UUID v4
            const randomBytes = [];
            for (let i = 0; i < 16; i++) {
              randomBytes.push(getRandomInt(0, 255));
            }

            // Set the version to 4 (UUID v4)
            randomBytes[6] = (randomBytes[6] & 0x0f) | 0x40; // version 4
            // Set the variant to 1 (RFC 4122 variant)
            randomBytes[8] = (randomBytes[8] & 0x3f) | 0x80;

            // Convert bytes to a UUID string
            const hex = randomBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');
            return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
          }

      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          CHATS_TABLE: !Ref ChatsTable

  CreateChatLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref CreateChatFunction
      Principal: 'apigateway.amazonaws.com'

  ApiGatewayResourceCreateChat:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'create-chat'

  ApiGatewayMethodCreateChat:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceCreateChat
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.header.Content-Type": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceCreateChat
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${CreateChatFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: {}

  ApiGatewayMethodOptionsCreateChat:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceCreateChat
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceCreateChat
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'POST,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"




  # Done
  SendMessageFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, PutCommand, UpdateCommand } = require("@aws-sdk/lib-dynamodb");

          const ddbClient = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
          const MESSAGES_TABLE = process.env.MESSAGES_TABLE;
          const CHATS_TABLE = process.env.CHATS_TABLE;

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,POST"
              }
            };

            try {
              const { chatId, userId, messageText } = JSON.parse(event.body);

              if (!chatId || !userId || !messageText) {
                throw new Error("Missing required fields: chatId, userId, messageText");
              }

              const messageId = generateUUID();
              const sentAt = new Date().toISOString();

              await ddbDocClient.send(new PutCommand({
                TableName: MESSAGES_TABLE,
                Item: {
                  messageId,
                  chatId,
                  userId,
                  messageText,
                  sentAt
                }
              }));

              await ddbDocClient.send(new UpdateCommand({
                TableName: CHATS_TABLE,
                Key: { chatId },
                UpdateExpression: 'SET lastMessageSent = :sentAt',
                ExpressionAttributeValues: {
                  ':sentAt': sentAt
                }
              }));

              return {
                ...response,
                body: JSON.stringify({ message: 'Message sent successfully' })
              };
            } catch (error) {
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({ message: `Error sending message: ${error.message}` })
              };
            }
          };

          function generateUUID() {
            function getRandomInt(min, max) {
              return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            const randomBytes = [];
            for (let i = 0; i < 16; i++) {
              randomBytes.push(getRandomInt(0, 255));
            }

            randomBytes[6] = (randomBytes[6] & 0x0f) | 0x40;
            randomBytes[8] = (randomBytes[8] & 0x3f) | 0x80;

            const hex = randomBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');
            return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
          }

      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          MESSAGES_TABLE: !Ref MessagesTable
          CHATS_TABLE: !Ref ChatsTable
  
  # Lambda Permission for API Gateway
  SendMessageLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref SendMessageFunction
      Principal: 'apigateway.amazonaws.com'

  # API Gateway Resource for Send Message
  ApiGatewayResourceSendMessage:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'send-message'

  # API Gateway Method for Send Message
  ApiGatewayMethodSendMessage:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceSendMessage
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters: {}
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SendMessageFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: {}

  # API Gateway Method OPTIONS for CORS
  ApiGatewayMethodOptionsSendMessage:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceSendMessage
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: {}
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'POST,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"





  GetUserListFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, GetCommand } = require("@aws-sdk/lib-dynamodb");

          const ddbClient = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
          const USERS_TABLE = process.env.USERS_TABLE;

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,GET"
              }
            };

            try {
              const { email } = event.queryStringParameters;
              // Fetch encrypted secret key and encryption shift from DynamoDB
              const getParams = {
                TableName: USERS_TABLE,
                Key: { email },
              };

              const data = await ddbDocClient.send(new GetCommand(getParams));
              if (!data.Item) {
                return {
                  ...response,
                  statusCode: 404,
                  body: JSON.stringify({ message: 'User not found' }),
                };
              }
                  
              return {
                ...response,
                body: JSON.stringify(data.Item)
              };
            } catch (error) {
              console.error(error);
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({ message: `Error fetching users: ${error.message}` })
              };
            }
          };

      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          USERS_TABLE: !Ref UsersTable

  GetUserListLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref GetUserListFunction
      Principal: 'apigateway.amazonaws.com'

  ApiGatewayResourceGetUserList:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'get-user-list'

  ApiGatewayMethodGetUserList:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceGetUserList
      HttpMethod: GET
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.querystring.email": true
        "method.request.header.Content-Type": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceGetUserList
        IntegrationHttpMethod: "GET"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetUserListFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: {}

  ApiGatewayMethodOptionsGetUserList:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceGetUserList
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceGetUserList
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'GET,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"





  GetChatsFunction:
    Type: 'AWS::Lambda::Function'
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, ScanCommand } = require("@aws-sdk/lib-dynamodb");

          const ddbClient = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
          const CHATS_TABLE = process.env.CHATS_TABLE;

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,GET"
              }
            };

            try {
              const { userId } = event.queryStringParameters;

              const params = {
                TableName: CHATS_TABLE,
                FilterExpression: 'contains(#users, :userId)',
                ExpressionAttributeNames: {
                  '#users': 'users'
                },
                ExpressionAttributeValues: {
                  ':userId': userId
                }
              };

              const result = await ddbDocClient.send(new ScanCommand(params));

              return {
                ...response,
                body: JSON.stringify(result.Items)
              };
            } catch (error) {
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({ message: `Error fetching chats: ${error.message}` })
              };
            }
          };
      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          CHATS_TABLE: !Ref ChatsTable

  GetChatsLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref GetChatsFunction
      Principal: 'apigateway.amazonaws.com'

  ApiGatewayResourceGetChats:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'get-chats'

  ApiGatewayMethodGetChats:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceGetChats
      HttpMethod: GET
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.querystring.userId": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceGetChats
        IntegrationHttpMethod: "GET"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetChatsFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: {}

  ApiGatewayMethodOptionsGetChats:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceGetChats
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceGetChats
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'GET,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"





  GetMessagesFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, ScanCommand } = require("@aws-sdk/lib-dynamodb");

          const ddbClient = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
          const MESSAGES_TABLE = process.env.MESSAGES_TABLE;

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,GET"
              }
            };

            try {
              const { chatId } = event.queryStringParameters;

              const params = {
                TableName: MESSAGES_TABLE,
                FilterExpression: 'chatId = :chatId',
                ExpressionAttributeValues: {
                  ':chatId': chatId
                }
              };

              const result = await ddbDocClient.send(new ScanCommand(params));

              return {
                ...response,
                body: JSON.stringify(result.Items)
              };
            } catch (error) {
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({ message: `Error fetching messages: ${error.message}` })
              };
            }
          };
      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          MESSAGES_TABLE: !Ref MessagesTable

  GetMessagesLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref GetMessagesFunction
      Principal: 'apigateway.amazonaws.com'

  ApiGatewayResourceGetMessages:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'get-messages'

  ApiGatewayMethodGetMessages:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceGetMessages
      HttpMethod: GET
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.querystring.chatId": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceGetMessages
        IntegrationHttpMethod: "GET"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetMessagesFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: {}

  ApiGatewayMethodOptionsGetMessages:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceGetMessages
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceGetMessages
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'GET,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"





  DeleteMessageFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, DeleteCommand } = require("@aws-sdk/lib-dynamodb");

          const ddbClient = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
          const MESSAGES_TABLE = process.env.MESSAGES_TABLE;

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,DELETE"
              }
            };

            try {
              const { messageId } = event.queryStringParameters;

              await ddbDocClient.send(new DeleteCommand({
                TableName: MESSAGES_TABLE,
                Key: { messageId }
              }));

              return {
                ...response,
                body: JSON.stringify({ message: 'Message deleted successfully' })
              };
            } catch (error) {
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({ message: `Error deleting message: ${error.message}` })
              };
            }
          };
      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          MESSAGES_TABLE: !Ref MessagesTable

  DeleteMessageLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref DeleteMessageFunction
      Principal: 'apigateway.amazonaws.com'

  ApiGatewayResourceDeleteMessage:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'delete-message'

  ApiGatewayMethodDeleteMessage:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceDeleteMessage
      HttpMethod: DELETE
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.querystring.messageId": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'DELETE,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceDeleteMessage
        IntegrationHttpMethod: "DELETE"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DeleteMessageFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'DELETE,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: {}

  ApiGatewayMethodOptionsDeleteMessage:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceDeleteMessage
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceDeleteMessage
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'DELETE,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"





  EditMessageFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: 'index.handler'
      Role: !Ref RoleARN
      Code:
        ZipFile: |
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, UpdateCommand } = require("@aws-sdk/lib-dynamodb");

          const ddbClient = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
          const MESSAGES_TABLE = process.env.MESSAGES_TABLE;

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,PUT"
              }
            };

            try {
              const { messageId, newMessageText } = JSON.parse(event.body);

              await ddbDocClient.send(new UpdateCommand({
                TableName: MESSAGES_TABLE,
                Key: { messageId },
                UpdateExpression: 'SET messageText = :newMessageText',
                ExpressionAttributeValues: {
                  ':newMessageText': newMessageText
                }
              }));

              return {
                ...response,
                body: JSON.stringify({ message: 'Message updated successfully' })
              };
            } catch (error) {
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({ message: `Error updating message: ${error.message}` })
              };
            }
          };
      Runtime: 'nodejs20.x'
      Timeout: 30
      Environment:
        Variables:
          MESSAGES_TABLE: !Ref MessagesTable

  EditMessageLambdaInvokePermission:
    Type: 'AWS::Lambda::Permission'
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !Ref EditMessageFunction
      Principal: 'apigateway.amazonaws.com'

  ApiGatewayResourceEditMessage:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: 'edit-message'

  ApiGatewayMethodEditMessage:
    Type: 'AWS::ApiGateway::Method'
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceEditMessage
      HttpMethod: PUT
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.querystring.messageId": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'PUT,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceEditMessage
        IntegrationHttpMethod: "PUT"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${EditMessageFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'PUT,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: {}

  ApiGatewayMethodOptionsEditMessage:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceEditMessage
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceEditMessage
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              "method.response.header.Access-Control-Allow-Methods": "'PUT,OPTIONS'"
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            ResponseTemplates: { }
            StatusCode: "200"
        RequestTemplates:
          "application/json": "{statusCode:200}"
        Type: "MOCK"





  ApiGatewayRestApi:
    Type: 'AWS::ApiGateway::RestApi'
    Properties:
      Name: 'Chat-Api'
      ApiKeySourceType: "HEADER"
      EndpointConfiguration:
        Types:
          - "REGIONAL"

  ApiGatewayMethodOptionsRoot:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceRoot
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceRoot
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'OPTIONS,POST,GET'"  # Update this with the allowed methods
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            StatusCode: "200"
        PassthroughBehavior: "WHEN_NO_MATCH"
        RequestTemplates:
          "application/json": "{\"statusCode\": 200}"
        TimeoutInMillis: 29000
        Type: "MOCK"

  # OPTIONS method for the root resource
  ApiGatewayResourceRoot:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: "{proxy+}"

  ApiGatewayDeployment:
    Type: 'AWS::ApiGateway::Deployment'
    DependsOn:
      - ApiGatewayMethodCreateUser
      - ApiGatewayMethodLogin
      - ApiGatewayMethodGetUserList
      - ApiGatewayMethodCreateChat
      - ApiGatewayMethodGetChats
      - ApiGatewayMethodGetMessages
      - ApiGatewayMethodSendMessage
      - ApiGatewayMethodDeleteMessage
      - ApiGatewayMethodEditMessage
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      StageName: !Ref Stage

Outputs:
  ApiUrl:
    Description: 'URL for the API endpoint'
    Value:
      Fn::Sub: "https://${ApiGatewayRestApi}.execute-api.${AWS::Region}.amazonaws.com/${Stage}/user-auth"
